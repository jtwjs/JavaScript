# 코드에서 나는 악취

```
냄새 나면 당장 갈아라.
- 켄트 백 할머니의 육아 원칙
```

### 기이한 이름

코드는 단순하고 명료하게 작성해야 한다.
코드를 명료하게 표현하는데 가장 중요한 요소 하나는 바로 '이름'이다. 그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.

하지만 아쉽게도 이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 두 가지중 하나다. 그 때문에 우리가 가장 많이 사용하는 리팩터링도 `함수 선언 바꾸기`(함수 이름을 바꿀때도 사용한다), `변수 이름 바꾸기`, `필드 이름 바꾸기`처럼 이름을 바꾸는 리팩터링이다.
이름만 잘 지어도 나중에 문맥을 파악하느라 해매는 시간을 크게 절약할수 있다.

이름바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란 스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

### 중복 코드

똑같은 코드가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들수 있다. 코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.그 중 하나를 변경 할 떄는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.

가장 간단한 중복 코드의 예로, 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우가 있다. 이럴 때는 `함수 추출하기`를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다. 코드가 비슷하긴 한데 완전히 똑같지는 않다면, 먼저 `문장 슬라이드하기`로 비슷한 부분을 한곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다. 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어있다면, 각자 따로 호출되지 않도록 `메서드 올리기`를 적용해 부모로 옮긴다.

### 긴 함수

짧은 함수들로 구성된 코드베이스를 얼핏 훑으면 연산하는 부분이 하나도 없어 보인다. 코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다. 간접 호출의 효과, 즉 코드를 이해하고 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.

요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸다. 물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 여전히 부담이 된다. 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 없다.
'무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.

함수를 짧게 만드는 작업의 99%는 `함수 추출하기`가 차지한다. 함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것이다.

함수가 매개변수와 임시 변수를 많이 사용한다면 추출 작업에 방해가 된다. 이런 상황에서 함수를 추출하다 보면 추출된 함수에도 매개변수가 너무 많아져서 리팩터링 전보다 난해해질 수 있다.
그렇다면 `임시 변수를 질의 함수로 바꾸기`로 임시 변수의 수를, `매개변수 객체 만들기`와 `객체 통쨰로 넘기기`로는 매개변수의 수를 줄일 수 있을 것이다.

이 리팩터링들을 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 더 큰 수술이라 할 수 있는 `함수를 명령으로 바꾸기`를 고려해보자

추출할 코드 덩어리를 찾아내는 좋은 방법은 주석을 참고하는 것.
주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다. 코드가 단 한줄이어도 따로 설명할 필요가 있다면 함수로 추출하는게 좋다.

조건문이나 반복문도 추출 대상의 실마리를 제공한다.
조건문은 `조건문 대응하기`로 대응한다. 거대한 switch문을 구성하는 case문마다 `함수 추출하기`를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 `조건문을 다형성으로 바꾸기`를 적용한다.

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다. 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두가지 작업이 섞여 있기 떄문일 수 있다. 이럴떄는 과감히 `반복문 쪼개기`를 적용해서 작업을 분리한다.

### 긴 매개변수 목록

다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 `매개변수를 질의 함수로 바꾸기`로 제거할 수 있다. 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 `객체 통쨰로 넘기기`를 적용해서 원본 데이터 구조를 그대로 전달한다. 항상 함께 전달되는 매개변수들은 `매개변수 객체 만들기`로 하나로 묶어 버린다. 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 `플래그 인수 제거하기`로 없애준다.

클래스는 매개변수 목록을 줄이는데 효과적인 수단이기도 하다. 특히 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 떄 유리하다. 이럴떄는 `여러 함수를 클래스로 묶기`를 이용하여 공통 값들을 클래스 필드로 정의 한다.

### 전역 데이터

전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿧는지 찾아낼 메커니즘이 없다는게 문제다. 그래서 마치 '유령 같은 원격작용'처럼, 버그는 끊임없이 발생하는데 그 원인이 되는 코드를 찾아내기가 굉장히 어렵다. 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

이를 방지하기 위해 우리가 사용하는 대표적인 리팩터링은 `변수 캡슐화하기`다. 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 떄마다 이 기법을 가장 먼저 적용한다. 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을수 있고 접근을 통제할 수 있게 된다. 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할수 있도록 접근 범위를 최소로 줄이는것도 좋다.

### 가변 데이터

`변수 캡슐화하기`를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다. 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 `변수 쪼개기`를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다. 갱신 로직은 다른 코드와 떨어뜨려 놓는것이 좋다. 그러기 위해 `문장 슬라이드하기`와 `함수 추출하기`를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다. API를 만들 떄는 `질의 함수와 변경 함수 분리하기`를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할수 없게한다. 우리는 가능한한 `세터 제거하기`도 적용한다.

값을 다른 곳에서 설정할 수 있는 가변데이터는 제일 쓸데없는 코드이다. 이럴 때는 `파생 변수를 질의함수로 바꾸기`에 식초 농축액을 석어서 코드 전체에 골고루 뿌려준다.

`여러 함수를 클래스로 묶기`나 `여러 함수를 변환 함수로 묶기`를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한한다.

### 뒤엉킨 변경

뒤엉킨 변경은 단일 책임 원칙(Single Responsibility Principle; SRP)이 제데로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러가지 방식으로 변경되는 일이 많을 때 발생함

전체 처리과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다.(`함수옮기기`), 그러면 처리 과정이 맥락별로 구분된다. 이때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 `함수 추출하기`부터 수행한다.모듈이 클래스라면 `클래스 추출하기`가 맥락별 분리 방법을 잘 안내해줄 것이다.

### 산탄총 수술

산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다
이 냄새나는 코드를 변경할 떄마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다. 변경할 부분이 코드 전반에 퍼져 있다면 차직도 어렵고 꼭 수정해야 할곳을 지나치기 쉽다.

이럴 떄는 함께 변경되는 대상들을 `함수옮기기`와 `필드옮기기`로 모두 한 모듈에 묶어두면 좋다. 비슷한 데이터를 다루는 함수가 많다면 `여러 함수를 클래스로 묶기`를 적용한다. 데이터구조를 변환하거나 보강하는 함수들에는 `여러 함수를 변환 함수로 묶기`를 적용한다. 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 `단계 쪼개기`를 적용한다.

어설프게 분리된 로직을 `함수 인라인하기`나 `클래스 인라인하기`같은 인라인 리팩터링으로 하나로 합치는것도 산탄총 수술에 대처하는 좋은 방법이다.
코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는데 개의치 않는다.

### 기능 편애

프로그램을 모듈화할 떄는 코드를 여러 영역으로 나눈뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력한다. 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터와 상호작용 할일이 더많을 떄 풍기는 냄새다.

떄로는 함수의 일부에서만 기능을 편애할수 있다. 이럴떄는 그 부분만 독립함수로 빼낸다음(`함수 추출하기`) 원하는 모듈로 보내준다(`함수 옮기기`)

### 데이터 뭉치

필드 형태의 데이터 뭉치를 찾아서 `클래스 추출하기`로 하나의 객체로 묶는다. 다음은 메서드 시그니처에 있는 데이터 뭉치 차례다. 먼저 `매개변수 객체 만들기`나 `객체 통째로 넘기기`를 적용해서 매개변수 수를 줄여본다. 그 즉시 메서드 호출 코드가 간결해질것이다.

데이터 뭉치인지 판별하려면 값 하나를 삭제해보자, 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

### 기본형 집착

`기본형을 객체로 바꾸기`를 적용하면 기본형만이 거주하는 구석기 동굴을 의미 있는 자료형들이 사는 최신 온돌식 코드로 탈바꿈시킬수 있다.
기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰였다면 `타입 코드를 서브클래스로 바꾸기`와 `조건부 로직을 다형성으로 바꾸기`를 차례로 적용한다.

자주 함꼐 몰려다니는 기본형 그룹도 데이터 뭉치다. 따라서 `클래스 추출하기`와 `매개변수 객체만들기`를 이용하여 반드시 문명사회로 이끌어줘야 한다.

### 반복되는 switch문

요즘은 단순히 switch문을 썻다고 해서 자동으로 검토 대상은 되지는 않는 세상이 되었다.

중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할때마다 다른 switch문들도 모두 찾아서 함꼐 수정해야 하기 때문이다. 이럴 떄 다형성은 반복된 switch문이 내뿜는 사악한 기운을 제압하여 코드베이스르 최신 스타일로 바꿔주는 세련된 무기인 셈이다.

### 반복문

지금은 일급함수를 지원하는 언어가 많아졌기 때문에 `반복문을 파이프라인으로 바꾸기`를 적용해서 시대에 걸맞지 않은 반복문을 제거할수 있게 되었다.
필터(filter)나 맵(map)같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

### 추측성 일반화

`나중에 필요할 거야`라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이케이스 처리 로직을 작성해둔 코드에서 풍긴다. 그 결과는 물론 이해하거나 관리 하기 어려워진 코드다. 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데없는 낭비일 뿐이다. 당장 걸리적거리는 코드는 눈앞에서 치워버리자

하는 일이 거의 없거나 추상 클래스는 `계층 합치기`로 제거한다. 쓸데 없이 위임하는 코드는 `함수 인라인하기`나 `클래스 인라인하기`로 삭제한다. 본문에서 사용되지 않는 매개변수는 `함수 선언 바꾸기`로 없앤다. 나중에 다른 버전을 만들때 필요할거라는 생각에 추가했지만 한번도 사용한적 없는 매개변수도 이 기법으로 제거한다.

추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼수 있다. 이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤에 `죽은 코드 제거하기`로 날려버리자

### 중개자

객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다. 캡슐화하는 과정에서는 위임이 자주 활용된다. 예를들어 여러분이 팀장에게 미팅을 요청한다면 팀장은 자신의 일정을 확인한 후 답을 준다. 이러면 끝이다. 팀장이 종이 다이어리를 쓰든, 일정 서비스를 쓰든, 따로 비서를 두든 우리는 알바가 아니다.

하지만 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 어떤가? 이럴 떄는 `중개자 제거하기`를 활용하여 실제로 일을 하는 객체와 직접 소통하게하자 위임 메서드를 제거한 후 남는일이 거의 없다면 호출하는 쪽으로 인라인 하자

### 내부자 거래

소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우기를 좋아하며, 그래서 모듈 사이의 데이터거래가 많으면 결합도(coupling)가 높아진다고 투덜댄다. 일이 돌아가게 하려면 거래가 이뤄질수밖에 없지만 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

커피 자판기 옆에서 은밀히 데이터를 주고받는 모듈들이 있다면 `함수 옮기기`와 `필드 옮기기`기 법으로 떼어놓아서 사적으로 처리하는 부분을줄인다. 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제 3의모듈을 새로만들거나 `위임 숨기기`를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.

### 거대한 클래스

한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

이럴 떄는 `클래스 추출하기`로 필드들 일부를 따로 묶는다. 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택하면 된다.
더 일반적으로, 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함꼐 추출할 후보들이다. 이렇게 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면 (클래스 추출하기보다는) `슈퍼클래스 추출하기`나 (실질적으로 서브클래스추출하기에 해당하는)`타입 코드를 서브클래스로 바꾸기`를 적용하는편이 더쉬움

클라이언트들이 거대 클래스를 이용하는지 패턴을 파악하여 그 클래스를 어떻게 쪼갤지 단서를 얻을수도 있다. 유용한 기능 그룹을 찾았다면 `클래스 추출하기` `슈퍼클래스 추출하기` `타입 코드를 서브클래스로 바꾸기`드응ㄹ 활용해서 여러 클래스로 분리한다.

### 데이터 클래스

데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 그저 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰때가 많다. 이런 클래스에 public 필드가 있다면 누가 보기전에 `레코드 캡슐화하기`로 숨기자 변경하면 안되는 필드는 `세터 제거하기`로 접근을 원천 봉쇄한다.

### 주석

주석이 많으면 온갖 악취를 풍기는 코드가 나오기 쉽다.

특정 코드 블록이 하는 일에 주석을 남기고 싶다면 `함수 추출하기`를 적용해본다. 이미 추출되어있는 함수임에도 여전히 설명이 필요하다면 `함수 선언바꾸기`로 함수 이름을 바꿔본다.
시스템이 동작하기 위한 선행조건을 명시하고 싶다면 `어서션 추가하기`가 대기하고 있다.

```
    주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다.
```

뭘할지 모를때라면 주석을 달아두면 좋다. 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 주석에 남긴다. 코드를 지금처럼 작성한 이유를 설명하는 용도로 달수 있다.
