## 스코프(scope)

> 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정한다.

- ```js
  function f(x) {
    return x + 3;
  }
  f(5); //8
  x; //ReferenceError: x is not defined
  //x의 스코프는 함수 f

  /*함수는 여러번 호출할수 있고 함수를 호출할 때마다 매개변수가 나타나고, 
  함수가 제어권을 반환하면 스코프 밖으로 사라진다.*/
  ```

### 스코프와 존재

> 가시성이라고도 불리는 스코프는 프로그램의 현재 실행 중인 부분, 즉 실행컨텍스트에서 현재 보이고 접근할 수 있는 식별자들을 말한다.
> <br>존재한다는 말은 그 식별자가 메모리가 할당된(예약된) 무언가를 가리키고 있다는 뜻이다.

- 무언가가 더는 존재하지 않는다고 해도 자바스크립트는 메모리를 바로 회수하지 않는다.
  - 그것을 계속 유지할 필요가 없다고 표시해 두면, 주기적으로 일어나는 가비지 컬렉션 프로세스에서 메모리를 회수한다.

### 정적 스코프와 동적 스코프

- 정적 스코프는 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다는 뜻
- ```js
  const x = 3;

  function f() {
    console.log(x);
    console.log(y);
  }

  {
    //새 스코프
    const y = 5;
    f();
  }
  /*함수 f는 자신이 정의될 때 접근할 수 있었던 식별자에는 여전히 접근할 수 있지만, 
  호출할 때 스코프에 있는 식별자에 접근할 수는 없다.*/
  ```

- 자바스크립트의 정적 스코프는 전역 스코프와 블록 스코프, 함수 스코프에 적용된다.

### 전역 스코프

> 스코프는 계층적이며 트리의 맨 아래에는 바탕이 되는 무언가가 있어야 한다.
> <Br> 즉, 프로그램을 시작할 때 암시적으로 주어지는 스코프가 필요하다.<br> 이 스코프가 전역 스코프이다.

- 전역 스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있다.
- 전역 스코프에서 선언된 것들을 전역 변수라고 한다.
  - 전역 스코프에 있는 것이 모든 스코프에서 보이므로 조심해서 사용해야한다.

### 블록 스코프

> 블록 스코프는 그 블록의 스코프에서만 보이는 식별자를 의미한다.

- let과 const는 식별자를 블록 스코프에서 선언한다.
- 블록은 보통 if나 for 같은 제어문의 일부분으로 쓰이지만, 블록 그 자체로도 유효한 문법이다.
  - 독립 블록은 현실적인 쓸모는 별로 없다.

### 변수 숨기기

- ```js
  {
    //외부 블록
    let x = { color: "blue" };
    let y = x; //y와 x는 같은 객체를 가리킴
    let z = 3;
    {
      //내부 블록
      let x = 5; //이제 바깥의 x는 가려졌다.
      console.log(x); //5
      console.log(y.color); //"blue"; y가 가리키는,
      //외부 스코프의 x가 가리키는 객체는 스코프 안에 있다.

      y.color = "red";
      console.log(z); // 3; z는 숨겨지지 않았다.
    }
    console.log(x.color); //"red"; 객체는 내부 스코프에서 수정됐다.
    console.log(y.color); //"red"; x와 y는 같은 객체를 가리킨다.
    console.log(z); //3
  }
  ```

- 이전 스코프를 떠나지 않아도 새 스코프에 진입할 수 있다.
- 스코프의 계층적인 성격 때문에 어떤 변수가 스코프에 있는지 확인하는 스코프 체인이란 개념이 생겨남
- 현재 스코프 체인에 있는 모든 변수는 스코프에 있는 것이며, 숨겨지지 않았다면 접근할 수 있다.

### 함수, 클로저, 정적 스코프

- **클로저(closure)**
  - 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 경우를 클로저라고 부른다.
  - 스코프를 함수 주변으로 좁히는 것이라고 생각해도 된다.
- ```js
  let globalFunc; //정의되지 않은 전역변수
  {
    let blockVar = "a"; //블록 스코프에 있는 변수
    globalFunc = function () {
      //블록 안에서 값을 할당 받음
      console.log(blockVar);
    };
    //이 블록 스코프와 그 부모인 전역 스코프가 클로저를 형성함
  }
  globalFunc(); //"a"
  //globalFunc를 어디서 호출하든, 이 함수는 클로저에 들어있는 식별자에 접근할 수 있다.
  ```

- 즉, 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지된다.
  - 또한 일반적으로는 접근할 수 없는 것에 접근할 수 있는 효과도 있다.
- ```js
  let f;
  {
    let o = { note: "Safe" };
    f = function () {
      return o;
    };
  }
  let oRef = f();
  oRef.note = "Not so safe after all!";
  ```
- 함수를 정의해 클로저를 만들면 접근할 수 없었던 것들에 접근할 방법이 생긴다.

### 즉시 호출하는 함수 표현식

> 함수 표현식을 사용하면 즉시 호출하는 함수 표현식(IIFE)이란 것을 만들 수 있다.<br>IIFE는 함수를 선언하고 즉시 실행한다.

- ```js
  (function () {
    // IIFE 바디
  })();

  //함수 표현식으로 익명 함수를 만들고, 그 함수를 즉시 호출한다.
  ```

- IIFE의 장점
  - 내부에 있는 것들이 모두 자신만의 스코프를 가지지만, IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있다.
- ```js
  const message = (function () {
    const secret = "I'm a sercret!";
    return `The secret is ${secret.length} characters long.`;
  })();
  console.log(message);

  const f = (function () {
    let count = 0;
    return function () {
      return `I have been called ${++count} time(s).`;
    };
  })();
  f(); //I have been called 1 time(s).
  f(); //I have been called 2 time(s).

  //변수 count는 IIFE 안에 안전하게 보관되어 있으므로 손댈 방법이 없다.
  //f는 자신이 몇번 호출됬는지에 정확히 알고 있다.
  ```

- ES6에서 블록 스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄어들긴 했지만 여전히 널리 쓰인다
- 클로저를 만들고 클로저에서 무언가를 반환받을 때에는 유용하게 쓸 수 있다.

### 함수 스코프와 호이스팅

> var로 선언한 변수는 끌어올린다는 뜻의 호이스팅이라는 메커니즘을 따른다.<br> 선언만 끌어올려진다는 것이며, 할당은 끌어올려지지 않는다.

- ```js
  var x; //선언(할당은 아닌)이 끌어올려짐
  x; //undefined
  x = 3;
  x; //3
  ```
- var와 호이스팅을 이해해야 하는 이유
  1. ES5의 코드 이해(var)
  2. 함수 선언 역시 끌어올려진다는 것

### 함수 호이스팅

> var로 선언된 변수와 마찬가지로, 함수 선언도 스코프 맨 위로 끌어 올려진다. <br> 따라서 함수를 선언하기 전에 호출할 수 있다.

- ```js
  f();
  function f() {
    console.log(`f`);
  }
  ```
- **변수에 할당한 함수표현식은 끌어올려지지 않는다.**
  - 이들은 변수의 스코프 규칙을 그대로 딷름
- ```js
  f(); //ReferenceError: f 는 정의되지 않았다.
  let f = function () {
    console.log("f");
  };
  ```

### 사각지대 (DMZ 존)

> let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념을 잘 나타내는 표현

- 스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드이다.
- ```js
  // typeof 연산자는 변수가 선언됐는지 알아볼 때 널리쓰이고 존재를 확인하는 안전한방법으로 알려져있엇다.(ES6 전까진)
  //Error
  if (typeof x === "undefined") {
    console.log("x doesn't exist or is undefined");
  } else {
    //x를 사용해도 안전한 코드
  }
  //사각지대

  let x = 5;
  //ES6에서는 typeof 연산자로 변수가 정의됐는지 확인할 필요가 거의 없으므로 typeof가 문제를 일으킬 소지도 거의 없다.
  ```

### 스트릭트 모드

> ES5 문법에서는 암시적 전역 변수라는 것이 생길 수 있었다. 암시적 전역변수는 여러가지 골치 아픈 에러를 일으키곤 했다.<BR> 간단히 말해 var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고, 그런 전역 변수가 존재하지 않으면 스스로 만들었다.

- 이런 이유로 자바스크립트에서는 스트릭트 모드를 도입했다.
  - 스트릭트 모드에서는 암시적 전역 변수를 허용하지 않는다.
  - 스트릭트 모드를 사용하려면 문자열 `"use strict"` 하나만으로 이루어진 행을 코드 맨 앞에 쓰면 된다.
  - 전역 스코프에서 스트릭트 모드를 실행하면 스크립트 전체가 스크립트 모드로 실행됨
- ```js
  (function () {
    "use strict";

    // 코드를 전부 이 안에 작성함
    // 이 코드는 스트릭트 모드로 동작하지만
    // 이 코드와 함꼐 동작하는 다른 스크립트는
    // 스크립트 모드에 영향받지 않는다.

  })();
  ```
